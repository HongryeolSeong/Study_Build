# Study_Build
업무에 필요한 프로그램 빌드에 대한 학습 내용입니다.

## 프로그램 동작 순서
![순서](https://t1.daumcdn.net/cfile/tistory/99E473355EC0FF5A07)

### 전처리
#include, #define, typedef, extern 과 같은 것들이 정의되어 실행되는 단계.   
main함수 위에 등록 된다.

### 컴파일
실제로 호출되고 사용되는 부분만 번역.   
어셈블리어(기계어)로 번역한다.

### 어셈블
다음 단계인 링킹에서 링커가 여러개의 바이너리 파일을 하나의 실행 파일로 묶게 되는데,   
각 바이너리의 정보를 효과적으로 파악하기 위해   
일정한 규칙을 갖게 형식화하여 목적파일을 생성한다.

### 링킹
만들어진 목적 파일들을 하나로 묶어 실행 파일을 만든다.   
링커는 목적 파일들과 프로그램에서 사용된 표준 C 라이브러리, 사용자 라이브러리들을 링크한다.

<br>

## 라이브러리
자주 사용되는 특정한 기능을 main 함수에서 분리시켜 놓음으로써,   
프로그램을 유지, 디버깅을 쉽게하고 컴파일 시간을 좀더 빠르게 할 수 있다.

### 1. 정적 라이브러리 Windows - .lib, Linux - .a
---
컴파일시 적재돼서 실행 파일에 라이브러리의 내용이 모두 들어간다.   

#### 장점
1. 런타임시 외부를 참조할 필요가 없어 속도가 빠르고 성능이 좋다.
2. 라이브러리를 따로 배포할 필요가 없다.

#### 단점
1. 같은 코드를 가진 여러 프로그램 실행시 메모리가 낭비된다.
2. 라이브러리 수정시 적용된 프로그램을 다시 재배포해야한다.

#### 라이브러리 생성 및 적용
##### 1. Windows
1. 라이브러리의 헤더파일과 소스 코드를 작성한다.   
![1]() ![2]()
2. 빌드하여 .lib을 생성한다.   
![3]()
3. 라이브러리를 적용할 프로젝트를 만들고, 디렉터리를 추가한다.   
속성 -> C/C++ -> 일반 -> 추가 포함 디렉터리 에 헤더파일 경로 입력   
속성 -> 링커 -> 일반 -> 추가 라이브러리 디렉터리 에 라이브러리 경로 입력   
속성 -> 링커 -> 입력 -> 추가 종속성 에 라이브러리 파일명 입력
4. 해당 프로젝트를 빌드 및 실행한다.   
![4]() ![5]()

##### 2. Linux
1. 라이브러리의 헤더파일과 소스 코드를 작성한다.   
![6]()   
![7]()
2. 목적 파일을 생성한다.   
![8]()   
![9]()
3. 정적 라이브러리 파일을 생성한다.   
![10]()   
![11]()
4. 라이브러리를 적용할 소스 코드를 만들고, 컴파일을 거쳐 실행 파일을 만들고 실행한다.   
![12]()   
![13]()   
![14]()

### 2. 동적 라이브러리 Windows - .dll, Linux - .so
여러 프로그램이 공통적으로 필요로 하는 기능들을 프로그램과 분리하여 필요할 때에만 불러내어 쓸 수 있게 만들어 놓은 것.

#### 장점
1. 메모리가 절약된다.
2. 쉽게 수정이 가능하다. -> 출시 후 지원이 가능하다.

#### 단점
1. 필요한 때에 참조가 필요하기에 속도가 느리고 성능이 낮아질 수 있다.
2. 실행 파일 배포시 라이브러리도 함께 배포해야 한다.
